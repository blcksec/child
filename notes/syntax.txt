++++++++++++++++++++++++++++++++
+++ Child                    +++
+++ New programming language +++
++++++++++++++++++++++++++++++++

Person := Object {
    modules << Archivable

    first_name := ""
    last_name := ""
    age := 0

    init(@first_name: "", @last_name: "") := {}

    ... est équivalent à :

    init(first_name: "", last_name: "") := {
        @first_name = first_name
        @last_name = last_name
    }

    full_name(capitalize: false) := {
        doc:
            Return the concatenation of first_name and last_name
        code:
            str := [first_name, last_name] join(" ")
            if(capitalize) { str captitalize } else { str }
        test:
            p := Person()
            test(p full_name == "Manuel Vila")
    }

    Text init(source<this>) := { value = source full_name }
}

Company := Object {
    name := ""
    boss := Person()

    init(@name, @boss) := {}
}

p1 := Person()
p2 := Person("Manu")
p3 := Person("Manu", "Vila")

c1 := Company(name: "Kindalab", boss: p3)

***

PersonTest := Test {
    initialization := {
        p := Person()
        test(p first_name == "")
    }

    full_name := {
        p := Person("Manu", "Vila")
        test(p full_name == "Manuel Vila")
    }
 }

PersonTest run

***

swith(letter) {
    'a':
        "This is a 'A'"
    'b':
        "This is a 'B'"
    else:
        "Unknown letter"
} print

***

Person := Object {
    create := { ... }
    create(name<Text>, age<Number>) := { ... }
    create(brother<Person>) := { ... }
    create(company: Company())
    create(childs,...)
}

***

Person := Object {
    name := Text()
    name get := { value capitalize }
    name set(val) := { value = val }
    name spy { "name changed!" print }
}

---------------

Un Module définit :

    * Forks
    * Childs

Un Module est défini par :

    * ForkedModules (ou simplement "Modules")
    * Parents

Création d'un objet :

Person = Object {
    modules << Archivable

    first_name := Text
    last_name := Text

    full_name(capitalize: false) -> str := {
        str = [first_name, last_name] join(" ")
        if(capitalize) { str captitalize! }
    }
}

Définition d'une méthode :

meth(a: 0, b: 0, operation<Closure>: Nil) -> r = {
    r = a + b
    operation()
}

Note à propos de Nil :

Nil est un pseudo module descendant de tous les modules. Il signifie "n'importe quoi" et peut donc se substituer à n'importe quel module.

~~~~~~~~~ à actualiser : ~~~~~~~~~

Appel d'une méthode :

meth { do_something } // le paramètre "operation" spécifiant un type, il récupère la closure

meth(1) { do_something } // équivalent à :
meth(1, { do_something }) // ou :
meth(1, closure { do_something })

Utilisation de keywords :

meth(b: 1)

L'itérateur "each" peut être défini ainsi :

each = method(&val: nil, &key: nil, limit: 0)

Et utilisé ainsi :

authors each(auth) { auth println }
authors each(val, key) { "#{key}: #{val}" println }
authors each(auth, limit: 3) { auth println }

Si l'identifiant "val" n'est pas spécifié, un identifiant générique peut-être utilisé :

authors map { val capitalize } join(", ") println

Définition d'une closure :

x = 2
exp = closure(e) { x^e }
exp(8) // -> 256

exp2 = &exp
exp2(8) // -> 256

Raccourci pour définir une closure sans paramètre :

x = 2
operation = { x^2 }

Définition d'un tableau :

arr = ["rouge", "vert", 3, nil, obj]

Définition d'un hash :

hsh = ["first_name" => "Manu", "last_name" => "Vila", "age" => 37]

Indexation :

arr[0]
arr[1]
arr[1..-1] // Tous les éléments sauf le premier
arr[0..-2] // Tous les éléments sauf le dernier
arr[-1]    // Uniquement le dernier élément

hsh["first_name"]
hsh["age"]

Structures de contrôle :

if(i > 0) {
    "bonjour" print
  else:
    "au revoir" print
}

... ou la version "Syntaxic Sugar" :

if(i > 0) { "bonjour" print } else { "au revoir" print }

unless(val) { return }

switch(i) {
    case(5): do_something
    case(9): do_something_else
    else: panic("arf")
}

loop { infinte_loop }

x = 1
while(x < 10) { x++ println }

until(x > 10) { x++ println } // S'exécute au moins une fois, peu importe le résultat de la condition

Constructeurs permettant de faire des conversions de type :

String(123)  // -> "123"
Number("77") // -> 77
Array(12)    // -> [12]

---------------

Meta-slots :

Person = Object clone {
    name = ""
    name.output_filter = method(val) { val upcase }
    name.spy { "name changed" println }
}

p = Person clone
p name.output_filter = nil
p name.spy { "Yo" println }

name.spy { ... } -> spy("name", { ... })
spy = method(slot, block)

copy.enabled = true -> enabled.setter("copy", true)
enabled.setter = method(slot, block) { ... } -> setter("enabled", method(...))
setter = method(slot, val)

---------------------------------------------------

Calculator do {
    sum = { |a, b -> r| r = a + b }
}

---------------------------------------------------

* Multi-value
* Closure everywhere
* Action/Property
* TextField = Property
* Button = Action

app(name: "Hello World!") {
    window(width: 100, height: 200) {
    first_name = property
    last_name = property
    field {
    first_name = "Manu"
    companies each(#(comp, comp printl))
    }
    button {
    click = { close }
    }
    }
}

add = { |x, y| x + y }

authors each { |auth| auth println }

Author = [
    protos = Object
    first = nil
    last = nil
]

a = [ protos << Author, first = "Manu" ]


Author = {

}

Les identifiants débutant par une majuscule sont "activables" par défaut !

Button = Object {
    title = ""
    show = { ... }
}

b = Button { title = "OK" }

Handlers :

    * Par défaut, un message ou un bloc envoyé à un receiver est exécuté sur ce receiver. Un message retourne le résultat de la méthode associée alors qu'un bloc retourne le receiver.
    * L'handler est customizable, pour faire à peu près tout ce qu'on veut avec le message ou le bloc reçu. C'est ainsi que sont implémentés les méthodes each, select, inject, etc.


Résultat des méthodes :

    * meth = |x, y -> r| {
        if x > 1 { "Hello".println }
        r = 5
    }
    *	swap = |x, y -> y, x|
    * square = |x -> x^2|
    * si le résultat n'est pas précisé, c'est le receiver qui est retourné.

authors.each |auth| { if auth == "Manu" { exit } }

authors.select |auth -> selected| { selected = auth.human? }

???????????????

v kind_of?(Button)

b = Button { name = "OK" }

Quand on exécute une méthode :

    * Créer un clone du receiver
    * Exécuter les paramètres dans ce contexte
    * Exécuter le corp de la méthode

Author first = "Manu"

Button = View clone {
    traits << Watchable
    name = nil
    size = nil
    show = { view show }
    hide = { view hide }
}

View = Object clone {
    Button = clone {}
}

Window(width: 50, height: 100) {
    Button(name: "OK")
}

-------------------------------

Object:
    * proto
    * modules
    * parent
    * slots

-------------------------------

each(<Number>limit = nil, <Proc>code -> result) = {

}

if(i > 1) {
    ...
} else {
    ...
}

-------------------------------

Person full_name = { [first, last] join }
Person capitalize! = { first capitalize!; last capitalize! }
Person kill!(date = Date.today) = {
    dead? = true
    date_of_death = date
}

Person {
    first = ""
}

p = Person clone
p first = "Manu"

Une méthode a pour prototype "Method" et pour parent le receiver. Ainsi, un message inconnu est redirigé vers le receiver.

L'appel d'une methode "m" trouvée dans les prototypes d'un receiver "r" entraîne le clonage de "m" et le changement du parent pour le faire correspondre à "r".

L'appel d'une méthode "m" trouvée dans les parents d'un receiver "r" entraîne le clonage de "m" et le changement du parent dans le cas où la méthode a été trouvée dans un prototype d'un parent (le parent du clone de "m" devient alors le parent de "r" ayant un prototype répondant à la méthode).

Le prototype "Method" contient une seule méthode nommée "this" qui renvoie le clone de la méthode en cours d'exécution. Un "Reflector" peut alors être utilisé pour avoir un contrôle total sur ce clone.

Le prototype "Objet" contient une méthode "self" qui renvoie le receiver.

meth = {
    "hello" println
    a = 1
    // Le prototype de "c" est "Closure" et le parent est "this"
    c = { a * 2 }
    // L'appel de "c" entraîne son clonage et le parent est conservé
    c println
}

Closure avec paramètres :

c = { |a, b| a + b }

str = ""
authors each { str += its full_name }

full_name = {
    |first, last -> r|
    r = first
    if(last) {
    if(first) { r = r + " " }
    r = r + last
    }
}

full_name = method(first, last -> r) {
    r = first
    if(last) {
    if(first) { r = r + " " }
    r = r + last
    }
}

authors each { it println }

est équivalent à :

authors each(closure(it) { println })

---------------

Idée : un bloc de code envoyé à un objet non activable active ce dernier.

manu = Person { first = "Manu"; last = "Vila" }

... equivalent à :

manu = Person()

---------------

Plus clair ainsi :

company = "Kindalab"

manu = Person new {
    first = "Manu"
    last = "Vila"
    company = outer company
}

---------------

Meta-données :

O = Object clone {
    copy = method {}
}

o = O clone

o &copy enabled = true

o &copy watch { do_something }

---------------

app = application {
    win = window {
    button("Close") {
    spy(click) { close }
    }
    button("Quit") {
    spy(click) { quit }
    }
    }
}

---------------

Company: Object {
    name: String
    activity: String
    boss: Person
    employees: Person[]
    count = 0
}

Person: Object {
    first_name: String
    last_name: String
}

kl: Company {
    name = "Kindalab"
    activity = "Internet"
    boss first_name = "Manuel"
    boss last_name = "Vila"
}

comp: Company
comp name = "3base"

comp count++

---------------

Company = *Object {
    name = *String
    activity = *String
    boss = *Person
    employees = *Person[]
    count = 0
}

Person = *Object {
    first_name = *String
    last_name = *String
}

kl = *Company {
    name = "Kindalab"
    activity = "Internet"
    boss first_name = "Manuel"
    boss last_name = "Vila"
}

comp = *Company
comp boss first_name = "3base"

comp count++

---------------

Company = Object clone {
    name = ""
    activity = ""
    boss = Person clone
}

Person = Object clone {
    first_name = ""
    last_name = ""
    age = 0
}

comp = Company clone
comp.boss.age.watchers << { "age changed" print }
ben = Person clone { first_name = "Benoît", age = 37 }
comp boss = ben
ben age++

