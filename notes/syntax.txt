++++++++++++++++++++++++++++++++
+++ Child                    +++
+++ New programming language +++
++++++++++++++++++++++++++++++++

"Hello, World!" print

Version orienté objet :

Hello := Object {
   init(@what: "World") := {}
   say := { "Hello, #{what}!" print }
}

Hello() say // -> "Hello, World!"
Hello("Manu") say // -> "Hello, Manu!"

***

Person := Object {
    extensions << Archivable

    first_name := "" // Pas nécessaire car initialisé par la méthode "init"
    last_name := ""
    age := 0

    init(@first_name: "", @last_name: "") := {}

    ... est équivalent à :

    init(first_name: "", last_name: "") := {
        @first_name = first_name
        @last_name = last_name
    }

    full_name(capitalize: false) := {
        doc:
            "Return the concatenation of first_name and last_name"
        code:
            str := [first_name, last_name] join(" ")
            if(capitalize) { str captitalize } else { str }
        test:
            p := Person()
            assert(p full_name == "Manuel Vila")
    }

    converters["Text"] := { full_name }
}

Person full_name // est équivalent à :
Person &full_name code

Person &full_name doc print // affiche la documentation attachée à la méthode

Person &full_name test // exécute la méthode de test

Company := Object {
    name := ""
    boss := Person()

    init(@name, @boss) := {}
}

p1 := Person()
p2 := Person("Manu")
p3 := Person("Manu", "Vila")

c1 := Company(name: "Kindalab", boss: p3)

***

each(&var: item) {code} := {

}

map(&var: item) {code} -> result: [] := {

}

***

swith(letter) {
    'a':
        "This is a 'A'"
    'b':
        "This is a 'B'"
    else:
        "Unknown letter"
} print

***

Person := Object {
    create := { ... }
    create(name<Text>, age<Number>) := { ... }
    create(brother<Person>) := { ... }
    create(company: Company())
    create(name: "", age: -1)
    create(childs,...)
}

***

Person := Object {
    name := Text()
    name get := { value capitalize }
    name set(val) := { value = val }
    name spy { "name changed!" print }
}

***

Différence entre une méthode est une closure ?

Person := Object {
    a := 123
    m1 := {
        a = 125
        b := 7
        m2 := {
            b = 9
        }
    }
}

Exécution d'une méthode :

1) On fork la méthode pour simuler un contexte local
2) On exécute
3) On join si tout s'est bien passé

p1 := Person()
p1 m1

m1' : m1 est cloné dans p1 pour servir de référence virtuelle
m1" : m1' est cloné avant l'exécution pour créer un contexte local
m1" modifie a :
    p1 est cloné en p1'
    a est cloné en a' et prend p1' pour père

---------------

Un Node définit :

    * Forks
    * ExtendedNodes
    * Childs

Un Node est défini par :

    * Origin
    * Extensions
    * Parents

Création d'un objet :

Person = Object {
    extensions << Archivable

    first_name := Text()
    last_name := Text()

    full_name(capitalize: false) -> txt := {
        txt = [first_name, last_name] join(" ")
        if(capitalize) { txt captitalize! }
    }
}

Définition d'une méthode :

meth(a: 0, b: 0) {operation: {}} -> r = {
    r = a + b
    operation
}

Appel d'une méthode :

meth1(1) { do_something }

... délégation :

meth1(a) {code} := {
    meth2(a) {:code}

    ...peut se traduire par :

    message(name: "meth2", inputs: [a], block: code)
}

meth(a, b, c: 0) := { do_something } se traduit par :

message(":=", message("meth", ["a", "b", c: 0]), { do_something })

meth(a, b: 0) {code} := { do_something } se traduit par :

message(":=", message("meth", ["a", b: 0, "{code}"]), { do_something })

meth(a, b: 0) {code: {}} := { do_something } se traduit par :

message(":=", message("meth", ["a", b: 0, "{code}": {}]), { do_something })

meth(a<Text>) := { do_something } se traduit par :

message(":=", message("meth", ["a<Text>"]), { do_something })

meth(a) -> r, e: 0 := { do_something } se traduit par :

message(":=", message("meth", inputs: ["a"], outputs: ["r", e: 0]), { do_something })

meth(a) {code} -> r := { do_something } se traduit par :

message(":=", message("meth", inputs: ["a", "{code}"], outputs: ["r"]), { do_something })

L'itérateur "each" peut être défini ainsi :

each(&val: nil, &key: nil, offset: 0, limit: nil) {code} := { implementation de each }

Et utilisé ainsi :

authors each(auth) { auth print }
authors each(val, key) { "#{key}: #{val}" print }
authors each(auth, limit: 3) { auth print }

Si l'identifiant "val" n'est pas spécifié, un identifiant générique est généré :

authors map { val capitalize } join(", ") print

Définition d'une liste :

list := ["rouge", "vert", 3, nil, obj]

Définition d'un dictionnaire :

dict := ["first_name": "Manu", "last_name": "Vila", "age": 37]

... peut être abrégé ainsi :

dict := [first_name: "Manu", last_name: "Vila", age: 37]

... peut contenir des clés anonymes :

dict := [action: "paint", "rouge", "vert", "bleu"]

... est représenté en interne par :

[action: "paint", \0: "rouge", \1: "vert", \2: "bleu"]

Indexation :

arr[0]
arr[1]
arr[1..-1] // Tous les éléments sauf le premier
arr[0..-2] // Tous les éléments sauf le dernier
arr[-1]    // Uniquement le dernier élément

hsh["first_name"] // ou hsh[first_name:]
hsh["age"]

~~~

Structures de contrôle :

if(i > 0) {
    "bonjour" print
  else:
    "au revoir" print
}

... ou la version "Syntaxic Sugar" :

if(i > 0) { "bonjour" print } else { "au revoir" print }

unless(val) { return }

switch(i) {
    5: do_something
    9: do_something_else
    else: panic("arf")
}

loop { infinte_loop }

x := 1; while(x < 10) { x++ print }

until(x > 10) { x++ print } // S'exécute au moins une fois, peu importe le résultat de la condition

Conversions de type :

Text(123)  // -> "123"
Number("77") // -> 77

Définition d'un convertisseur :

Person := Object {
    converters["Text"] := { full_name }
}

Une methode alert(msg<Text>) fera automatiquement appel au convertisseur si on passe autre chose que du Text en paramètre.

L'initializer d'un objet peut spécifier l'objet lui-même en guise de convertisseur :

Text := Object {
    init(src<Text>: "") := {
        implementation...
    }
}

Ainsi, on peut très simplement convertir une Person en Text :

mvila := Person("Manu", "Vila")
str := Text(mvila) + " is happy!"

Gestion des exceptions :

meth := {
    first := "Manu"
    last := "Vila"
    file := File("/tmp/image.jpg") open
    defer(file close) // defer the close message at the end of the current method

    <do something with the file...>

    NotFoundException("file not found") raise
    ...équivalent à :
    jump("NotFoundException", [exception: NotFoundException("file not found")])

    <never executed!>

  NotFoundException:
    "Not found!" log
  DuplicateException:
    "Duplicate!" log
  Exception: // Catch all other exceptions
    "#{exception name} intercepted!" log
}

---------------

Meta-slots :

Person = Object clone {
    name = ""
    name.output_filter = method(val) { val upcase }
    name.spy { "name changed" println }
}

p = Person clone
p name.output_filter = nil
p name.spy { "Yo" println }

name.spy { ... } -> spy("name", { ... })
spy = method(slot, block)

copy.enabled = true -> enabled.setter("copy", true)
enabled.setter = method(slot, block) { ... } -> setter("enabled", method(...))
setter = method(slot, val)

---------------------------------------------------

Calculator do {
    sum = { |a, b -> r| r = a + b }
}

---------------------------------------------------

* Multi-value
* Closure everywhere
* Action/Property
* TextField = Property
* Button = Action

app(name: "Hello World!") {
    window(width: 100, height: 200) {
    first_name = property
    last_name = property
    field {
    first_name = "Manu"
    companies each(#(comp, comp printl))
    }
    button {
    click = { close }
    }
    }
}

add = { |x, y| x + y }

authors each { |auth| auth println }

Author = [
    protos = Object
    first = nil
    last = nil
]

a = [ protos << Author, first = "Manu" ]


Author = {

}

Les identifiants débutant par une majuscule sont "activables" par défaut !

Button = Object {
    title = ""
    show = { ... }
}

b = Button { title = "OK" }

Handlers :

    * Par défaut, un message ou un bloc envoyé à un receiver est exécuté sur ce receiver. Un message retourne le résultat de la méthode associée alors qu'un bloc retourne le receiver.
    * L'handler est customizable, pour faire à peu près tout ce qu'on veut avec le message ou le bloc reçu. C'est ainsi que sont implémentés les méthodes each, select, inject, etc.


Résultat des méthodes :

    * meth = |x, y -> r| {
        if x > 1 { "Hello".println }
        r = 5
    }
    *	swap = |x, y -> y, x|
    * square = |x -> x^2|
    * si le résultat n'est pas précisé, c'est le receiver qui est retourné.

authors.each |auth| { if auth == "Manu" { exit } }

authors.select |auth -> selected| { selected = auth.human? }

???????????????

v kind_of?(Button)

b = Button { name = "OK" }

Quand on exécute une méthode :

    * Créer un clone du receiver
    * Exécuter les paramètres dans ce contexte
    * Exécuter le corp de la méthode

Author first = "Manu"

Button = View clone {
    traits << Watchable
    name = nil
    size = nil
    show = { view show }
    hide = { view hide }
}

View = Object clone {
    Button = clone {}
}

Window(width: 50, height: 100) {
    Button(name: "OK")
}

-------------------------------

Object:
    * proto
    * modules
    * parent
    * slots

-------------------------------

each(<Number>limit = nil, <Proc>code -> result) = {

}

if(i > 1) {
    ...
} else {
    ...
}

-------------------------------

Person full_name = { [first, last] join }
Person capitalize! = { first capitalize!; last capitalize! }
Person kill!(date = Date.today) = {
    dead? = true
    date_of_death = date
}

Person {
    first = ""
}

p = Person clone
p first = "Manu"

Une méthode a pour prototype "Method" et pour parent le receiver. Ainsi, un message inconnu est redirigé vers le receiver.

L'appel d'une methode "m" trouvée dans les prototypes d'un receiver "r" entraîne le clonage de "m" et le changement du parent pour le faire correspondre à "r".

L'appel d'une méthode "m" trouvée dans les parents d'un receiver "r" entraîne le clonage de "m" et le changement du parent dans le cas où la méthode a été trouvée dans un prototype d'un parent (le parent du clone de "m" devient alors le parent de "r" ayant un prototype répondant à la méthode).

Le prototype "Method" contient une seule méthode nommée "this" qui renvoie le clone de la méthode en cours d'exécution. Un "Reflector" peut alors être utilisé pour avoir un contrôle total sur ce clone.

Le prototype "Objet" contient une méthode "self" qui renvoie le receiver.

meth = {
    "hello" println
    a = 1
    // Le prototype de "c" est "Closure" et le parent est "this"
    c = { a * 2 }
    // L'appel de "c" entraîne son clonage et le parent est conservé
    c println
}

Closure avec paramètres :

c = { |a, b| a + b }

str = ""
authors each { str += its full_name }

full_name = {
    |first, last -> r|
    r = first
    if(last) {
    if(first) { r = r + " " }
    r = r + last
    }
}

full_name = method(first, last -> r) {
    r = first
    if(last) {
    if(first) { r = r + " " }
    r = r + last
    }
}

authors each { it println }

est équivalent à :

authors each(closure(it) { println })

---------------

Idée : un bloc de code envoyé à un objet non activable active ce dernier.

manu = Person { first = "Manu"; last = "Vila" }

... equivalent à :

manu = Person()

---------------

Plus clair ainsi :

company = "Kindalab"

manu = Person new {
    first = "Manu"
    last = "Vila"
    company = outer company
}

---------------

Meta-données :

O = Object clone {
    copy = method {}
}

o = O clone

o &copy enabled = true

o &copy watch { do_something }

---------------

app = application {
    win = window {
    button("Close") {
    spy(click) { close }
    }
    button("Quit") {
    spy(click) { quit }
    }
    }
}

---------------

Company: Object {
    name: String
    activity: String
    boss: Person
    employees: Person[]
    count = 0
}

Person: Object {
    first_name: String
    last_name: String
}

kl: Company {
    name = "Kindalab"
    activity = "Internet"
    boss first_name = "Manuel"
    boss last_name = "Vila"
}

comp: Company
comp name = "3base"

comp count++

---------------

Company = *Object {
    name = *String
    activity = *String
    boss = *Person
    employees = *Person[]
    count = 0
}

Person = *Object {
    first_name = *String
    last_name = *String
}

kl = *Company {
    name = "Kindalab"
    activity = "Internet"
    boss first_name = "Manuel"
    boss last_name = "Vila"
}

comp = *Company
comp boss first_name = "3base"

comp count++

---------------

Company = Object clone {
    name = ""
    activity = ""
    boss = Person clone
}

Person = Object clone {
    first_name = ""
    last_name = ""
    age = 0
}

comp = Company clone
comp.boss.age.watchers << { "age changed" print }
ben = Person clone { first_name = "Benoît", age = 37 }
comp boss = ben
ben age++

